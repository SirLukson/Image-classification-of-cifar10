# -*- coding: utf-8 -*-
"""Łukasz_Gałka.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SWwQxOPY97LTu0rt1G1Qoe8ZhhyLJm3-
"""

import numpy as np
import tensorflow as tf
import keras
from keras.models import Sequential
from keras.layers import Dense
from keras.layers import Dropout
from keras.layers import Flatten
#from keras.optimizers import SGD
from keras.layers import Activation
from keras.layers.convolutional import Conv2D
from keras.layers.convolutional import MaxPooling2D
from keras.layers.normalization import BatchNormalization
from keras.utils import np_utils
from keras.regularizers import l2

# Import bazy cifar10
from keras.datasets import cifar10

# Deklaracja zmiennych
batch_size = 32 # ilosc przykladow wsadowych
num_classes = 10 # liczba klas obrazków
epochs = 100 # ilość powtórzeń

(x_train, y_train), (x_test, y_test) = cifar10.load_data() # x_train - treningowe zdjecia, y_train - etykiety
print('x_train shape:', x_train.shape)
print(x_train.shape[0], 'train samples')
print(x_test.shape[0], 'test samples')

# Klasy zdjec

class_names = ['airplane','automobile','bird','cat','deer',
               'dog','frog','horse','ship','truck']

# Konwersja i preprocesing

y_train = np_utils.to_categorical(y_train, num_classes)
y_test = np_utils.to_categorical(y_test, num_classes)
x_train = x_train.astype('float32') #zamiana na float
x_test = x_test.astype('float32') #zamiana na float
x_train = x_train / 255 #normalizacja w w zakresie 0-1
x_test = x_test / 255 #normalizacja w w zakresie 0-1

# Definiowanie modelu sekwencyjnego sieci

# Model na podstawie rozwiązań architektury z modeli VGG4/6 oraz VGG16
# Conv2D warstwa konvolucyjna,
# (3,3)- wysokosc i szerokosc okna konwolucji,
# padding = 'same' - zapewnia ten sam rozmiar obrazka po przejsciu przez warstwe
# kernel_initializer - parametr ustawiajcy wage warstwy
# kernel_regulizer - parametr ustawiajacy "kare" dla warstwy

model = Sequential()
model.add(Conv2D(32, (3, 3), kernel_initializer = 'he_uniform', padding='same', kernel_regularizer=l2(0.001), input_shape=( 32, 32, 3)))
model.add(Conv2D(32, (3, 3), kernel_initializer = 'he_uniform', padding='same', kernel_regularizer=l2(0.001)))
model.add(Activation('relu')) # funkcja aktywacji relu normalizuje wynik wyjsciowy, jest efektywna obliczeniowo i przyspiesza trening
model.add(MaxPooling2D(pool_size=(2, 2))) # redukuje liczbe pixeli obrazka
model.add(Dropout(0.2)) # losowo ustawia wejscia na 0 z czestotliwoscia 0.2

model.add(Conv2D(64, (3, 3), kernel_initializer = 'he_uniform', padding='same', kernel_regularizer=l2(0.001)))
model.add(Conv2D(64, (3, 3), kernel_initializer = 'he_uniform', padding='same', kernel_regularizer=l2(0.001)))
model.add(Activation('relu'))
model.add(MaxPooling2D(pool_size=(2, 2)))
model.add(Dropout(0.2))

model.add(Conv2D(128, (3, 3), kernel_initializer = 'he_uniform', padding='same', kernel_regularizer=l2(0.001)))
model.add(Conv2D(128, (3, 3), kernel_initializer = 'he_uniform', padding='same', kernel_regularizer=l2(0.001)))
model.add(Activation('relu'))
model.add(MaxPooling2D(pool_size=(2, 2)))
model.add(Dropout(0.2))

model.add(Flatten())   # "wypłaszcza" wejście
# dense - warstwa gęstych klasyfikuje ostatecznie do jakiej kategorii nalezy dany obrazek i zwraca prawdopodobienstwo przynaleznosci
model.add(Dense(1024, activation = 'relu', kernel_initializer='he_uniform'))
model.add(Dense(num_classes))
model.add(Dropout(0.5))
model.add(Activation('softmax')) # funkcja aktywacji softmax normalizuje wynik wyjsciowy podajac go jako prawdopodobienstwo przynaleznosci

# Train model
# kompilacja modelu z uzyciem optimizera sigmoidalnego
sgd = SGD(lr = 0.001, decay=1e-6, nesterov=True)
model.compile(loss='categorical_crossentropy', optimizer=sgd, metrics=['accuracy'])

# Fit model

cnn = model.fit(x_train, y_train, batch_size=batch_size, epochs=epochs, validation_data=(x_test,y_test),shuffle=True)

# Result
scores = model.evaluate(x_test, y_test, verbose=0)
print("Accuracy: %.2f%%" % (scores[1]*100)) #Wyswietlanie skutecznosci sieci